/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package a2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class App {

    public static void main(String[] args) {

        // Reading out the test data as String and entering into lines
        // Change this path to file you want to use
        File file = new File("src/main/resources/hotels5.txt");

        System.out.println(file.getAbsolutePath());

        ArrayList<String> lines = new ArrayList<String>();

        try {

            Scanner scanner = new Scanner(file);

            while (scanner.hasNext()) {

                String line = scanner.nextLine();

                if (!line.startsWith("// ")) {
                    lines.add(line);
                }
            }

            scanner.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        // Saving first and second line seperately
        int num_of_hotels = Integer.parseInt(lines.get(0));
        int totalTime = Integer.parseInt(lines.get(1));

        lines.remove(1);
        lines.remove(0);

        System.out.println("Number of Hotels: " + num_of_hotels);
        System.out.println("Total Distance (Time in minutes): " + totalTime);

        // Entering remaining lines into hotels as objetcs of class Hotel
        ArrayList<Hotel> hotels = new ArrayList<Hotel>();

        for (int i = 0; i < lines.size(); i++) {
            String parts[] = lines.get(i).split(" ");
            hotels.add(new Hotel(Integer.parseInt(parts[0]), Float.parseFloat(parts[1])));
        }

        // Since we can drive at most 360 minutes daily for 5 days, the most we can
        // possibly drive is 1800 minutes
        // If this is exceeded, there is no possible route
        if (totalTime > 1800) {
            System.out.println("Error: Total route time exceeds theoretical maximum that can be completed");
            return;
        }

        float averageRating;
        ArrayList<Hotel> selectedHotels = createRoute(totalTime, hotels);

        if (selectedHotels == null)
            return;

        selectedHotels = optimizeRoute(totalTime, selectedHotels, hotels);

        //Output
        System.out.println();
        System.out.println("Selected Hotels:");
        for (int i = 0; i < selectedHotels.size(); i++)
            System.out.println("    Hotel " + i + ": " + selectedHotels.get(i).distance + " " + selectedHotels.get(i).rating);
        averageRating = calculateAverageRating(selectedHotels);
        System.out.println("Average Rating: " + averageRating);
    }

    /**
     * Creates a route through list hotels, always picking the farthest still reachable Hotels to minimize the amount of stops required
     * @param totalTime Endpoint that must be reached from the last Hotel in the route
     * @param hotels List of all Hotels
     * @return List of Hotels representing the route
     */
    static ArrayList<Hotel> createRoute(int totalTime, ArrayList<Hotel> hotels) {
        int currentTravelTime = 0;
        ArrayList<Hotel> selectedHotels = new ArrayList<Hotel>();
        while (currentTravelTime < totalTime - 360) {
            // use the farthest hotels within Range to make it to the end with certainty
            Hotel currentHotel = getFarthestHotelWithinRange(hotels, currentTravelTime);
            selectedHotels.add(currentHotel);
            currentTravelTime = currentHotel.distance;
            // if we require more than 4 stops the route is impossible
            if (selectedHotels.size() > 4) {
                System.out.println("Error: No possible route found");
                return null;
            }
        }
        return selectedHotels;
    }
    /**
     * Optimize the route of Hotels given in selectedHotels to maximise the average Score
     * @param totalTime Endpoint that must be reached from the last Hotel in the route
     * @param selectedHotels Route to be optimized
     * @param hotels List of all Hotels
     * @return optimized Route as a List of Hotels
     */
    static ArrayList<Hotel> optimizeRoute(int totalTime, ArrayList<Hotel> selectedHotels, ArrayList<Hotel> hotels) {
        int previousHotelDistance = 0;
        int nextHotelDistance = 0;
        float averageRating;
        ArrayList<Hotel> previousRoute = new ArrayList<Hotel>();

        // Keep repeating the optimization process until no further changes are made
        while (!previousRoute.equals(selectedHotels)) {
            // Saving the pre optimization route for comparison on next loop
            // Cast can go unchecked here, since selectedHotels.clone() will always return
            // ArrayList<Hotel>
            previousRoute = (ArrayList<Hotel>) selectedHotels.clone();
            // Check all currently selected hotels for optimizations
            for (int i = selectedHotels.size() - 1; i > -1; i--) {
                // Remember distances from starting point of previous and next hotel
                // If we are looking at the first hotel in the route, it must be in range of the
                // starting point instead
                if (i == 0) {
                    previousHotelDistance = 0;
                } else {
                    previousHotelDistance = selectedHotels.get(i - 1).distance;
                }
                // If we are looking at the last hotel in the route, it must be in range of the
                // end point instead
                if (i == selectedHotels.size() - 1) {
                    nextHotelDistance = totalTime;
                } else {
                    nextHotelDistance = selectedHotels.get(i + 1).distance;
                }
                // go over all remaining hotels and look for improvements over currentHotel
                Hotel currentHotel = selectedHotels.get(i);
                for (Hotel h : getRemainingHotels(hotels, selectedHotels)) {
                    // if Hotel h is in range of next and previous hotel and is an improvement over
                    // currentHotel, replace currentHotel with it
                    if (h.distance - previousHotelDistance < 360 && h.distance - previousHotelDistance > 0
                            && nextHotelDistance - h.distance < 360 && nextHotelDistance - h.distance > 0
                            && currentHotel.rating < h.rating) {
                        currentHotel = h;
                    }
                }
                // assign currentHotel at its place in selectedHotels
                selectedHotels.set(i, currentHotel);

                // If we still have stops left over use them to try and improve our average
                // rating
                averageRating = calculateAverageRating(selectedHotels);
                while (selectedHotels.size() < 4) {
                    // Use the average rating to determine if the best remaining hotel will increase
                    // it
                    averageRating = calculateAverageRating(selectedHotels);
                    Hotel bestRemaining = getBestRemainingHotel(hotels, selectedHotels);
                    if (bestRemaining.rating > averageRating)
                        selectedHotels.add(bestRemaining);
                    else
                        break;
                }
                // Sort hotels to ensure they are in correct order after changes
                Collections.sort(selectedHotels);
            }
        }
        return selectedHotels;
    }

    /**
     * Finds the farthest Hotel from list that is reachable from currentTravelTime
     * @param list List of Hotels to choose from
     * @param currentTravelTime specified point from which the Hotel must be reachable
     * @return farthest Hotel that is reachable from currentTravelTime
     */
    static Hotel getFarthestHotelWithinRange(ArrayList<Hotel> list, int currentTravelTime) {
        Hotel current = null;
        for (Hotel h : list) {
            if (current == null)
                current = h;
            if (current.distance <= h.distance && h.distance - currentTravelTime <= 360
                    && h.distance - currentTravelTime > 0)
                current = h;
        }
        return current;
    }

    /**
     * Removes selectedHotels from allHotels to get Hotels that are only in allHotels
     * @param allHotels List of all Hotels
     * @param selectedHotels List of Hotels to be removed
     * @return List of remaining Hotels
     */
    static ArrayList<Hotel> getRemainingHotels(ArrayList<Hotel> allHotels, ArrayList<Hotel> selectedHotels) {
        ArrayList<Hotel> remainingHotels = allHotels;
        for (Hotel h : selectedHotels) {
            remainingHotels.remove(h);
        }
        return remainingHotels;
    }

    /**
     * Calculates the average rating of given ArrayList of Hotels
     * 
     * @param list List of hotels
     * @return average Rating as float
     */
    static float calculateAverageRating(ArrayList<Hotel> list) {
        float average = 0;
        int counter = 0;
        for (Hotel h : list) {
            average += h.rating;
            counter++;
        }
        average = average / counter;
        return average;
    }

    /**
     * Finds the Hotel with the highest rating that is in allHotels but not in selectedHotels
     * @param allHotels List of all Hotels
     * @param selectedHotels List of Hotels that may not be chosen
     * @return Hotel with highest rating from allHotels which is not in selectedHotels
     */
    static Hotel getBestRemainingHotel(ArrayList<Hotel> allHotels, ArrayList<Hotel> selectedHotels) {

        ArrayList<Hotel> remainingHotels = getRemainingHotels(allHotels, selectedHotels);
        Hotel bestHotel = null;
        for (Hotel h : remainingHotels) {
            if (bestHotel == null || bestHotel.rating < h.rating)
                bestHotel = h;
        }
        return bestHotel;
    } 
}
